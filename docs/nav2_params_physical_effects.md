# Nav2 参数的实际物理效果解释

本文档用通俗的方式解释 Nav2 各个参数在真实机器人运行时会产生什么效果。

---

## 目录

1. [Nav2 整体架构](#1-nav2-整体架构)
2. [map_server 地图服务器](#2-map_server-地图服务器)
3. [AMCL 定位参数](#3-amcl-定位参数)
4. [bt_navigator 行为树导航器](#4-bt_navigator-行为树导航器)
5. [controller_server 控制器服务器](#5-controller_server-控制器服务器)
6. [planner_server 路径规划器](#6-planner_server-路径规划器)
7. [behavior_server 恢复行为服务器](#7-behavior_server-恢复行为服务器)
8. [local_costmap 局部代价地图](#8-local_costmap-局部代价地图)
9. [global_costmap 全局代价地图](#9-global_costmap-全局代价地图)
10. [常见问题与调优](#10-常见问题与调优)

---

## 1. Nav2 整体架构

在深入参数之前，先理解 Nav2 各个组件是如何协作的：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Nav2 整体架构                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────┐                                                        │
│  │ 用户/RViz2  │ ──→ 发送目标点 (goal_pose)                             │
│  └─────────────┘                                                        │
│         │                                                               │
│         ▼                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    bt_navigator (行为树导航器)                    │   │
│  │  作用：总指挥，协调所有组件，决定"现在该做什么"                     │   │
│  │  类比：导航 App 的主程序                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│         │                                                               │
│         ├──────────────────┬──────────────────┬─────────────────┐      │
│         ▼                  ▼                  ▼                 ▼      │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐   ┌──────────┐ │
│  │ AMCL        │    │ planner_    │    │ controller_ │   │ behavior_│ │
│  │ (定位)      │    │ server      │    │ server      │   │ server   │ │
│  │             │    │ (全局规划)   │    │ (局部控制)   │   │ (恢复)   │ │
│  │ "我在哪？"  │    │ "走哪条路？" │    │ "怎么走？"   │   │ "卡住了" │ │
│  └─────────────┘    └─────────────┘    └─────────────┘   └──────────┘ │
│         │                  │                  │                 │      │
│         │                  ▼                  ▼                 │      │
│         │           ┌─────────────┐    ┌─────────────┐          │      │
│         │           │ global_     │    │ local_      │          │      │
│         │           │ costmap     │    │ costmap     │          │      │
│         │           │ (全局地图)   │    │ (局部地图)   │          │      │
│         │           └─────────────┘    └─────────────┘          │      │
│         │                  │                  │                 │      │
│         └──────────────────┴────────┬─────────┴─────────────────┘      │
│                                     ▼                                   │
│                            ┌─────────────┐                              │
│                            │ map_server  │                              │
│                            │ (静态地图)   │                              │
│                            └─────────────┘                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**各组件职责**：

| 组件 | 职责 | 生活类比 |
|------|------|----------|
| **map_server** | 提供静态地图 | 纸质地图 |
| **AMCL** | 确定机器人在地图中的位置 | GPS 定位 |
| **bt_navigator** | 协调所有组件，管理导航流程 | 导航 App 主程序 |
| **planner_server** | 规划从起点到终点的全局路径 | 导航 App 的路线规划 |
| **controller_server** | 控制机器人沿路径行走 | 司机开车 |
| **behavior_server** | 处理异常情况（卡住、碰撞等） | 遇到问题时的应急处理 |
| **global_costmap** | 全局障碍物地图 | 整个城市的交通地图 |
| **local_costmap** | 局部障碍物地图 | 眼前 3 米的路况 |

---

## 2. map_server 地图服务器

**作用**：加载和发布静态地图（.pgm + .yaml 文件）

```yaml
map_server:
  ros__parameters:
    use_sim_time: False  # 真机用 False，仿真用 True
```

**生活类比**：就像把一张纸质地图摊开放在桌上，所有人都可以看。

```
地图文件结构：
├── map.pgm      # 图像文件（黑=障碍物，白=可通行，灰=未知）
└── map.yaml     # 配置文件（分辨率、原点等）

map.yaml 内容：
image: map.pgm
resolution: 0.05      # 每个像素代表 5cm
origin: [-10, -10, 0] # 地图原点在世界坐标系中的位置
```

**实际效果**：
| 参数 | 效果 |
|------|------|
| use_sim_time: True | 使用仿真时间（Gazebo），时间戳与仿真同步 |
| use_sim_time: False | 使用系统真实时间（真机），时间戳是当前时间 |

**你会看到的现象**：
- 真机环境用了 `use_sim_time: True`：TF 变换会报错，定位失败
- 仿真环境用了 `use_sim_time: False`：机器人位置不更新

---

## 3. AMCL 定位参数

AMCL 的作用是让机器人知道"我在地图的哪个位置"。

### 1.1 粒子数量 (min_particles / max_particles)

**生活类比**：想象你蒙着眼睛被放到一个房间里，你派出很多"分身"去探索，每个分身猜测一个可能的位置。

```
粒子少 (500)                    粒子多 (5000)
┌─────────────────┐            ┌─────────────────┐
│    ·    ·       │            │ · · · · · · · · │
│  ·    ·    ·    │            │ · · · · · · · · │
│    ·    ·       │            │ · · · · · · · · │
│  ·    ·    ·    │            │ · · · · · · · · │
└─────────────────┘            └─────────────────┘
  猜测位置少，可能不准确          猜测位置多，更可能找到正确位置
  但计算快                       但计算慢
```

**实际效果**：
| 粒子数 | 效果 |
|--------|------|
| 太少 (< 500) | 机器人可能"迷路"，在 RViz 中看到位置跳动 |
| 适中 (500-2000) | 定位稳定，CPU 占用合理 |
| 太多 (> 5000) | 定位很准，但 CPU 占用高，可能导致其他功能变慢 |

**你会看到的现象**：
- 粒子太少：机器人在 RViz 中的位置突然"跳"到另一个地方
- 粒子太多：电脑风扇狂转，其他程序变卡

### 1.2 更新触发条件 (update_min_d / update_min_a)

**生活类比**：你不需要每走一步就重新确认位置，而是走一段距离或转一个角度后再确认。

```
update_min_d = 0.2m (移动 20cm 才更新)
update_min_a = 0.5rad (转 29° 才更新)

机器人移动轨迹：
起点 ──────────────────────────────────────→ 终点
     ↑         ↑         ↑         ↑
     更新1     更新2     更新3     更新4
     (每20cm更新一次)
```

**实际效果**：
| 参数值 | 效果 |
|--------|------|
| 太小 (0.05m) | 频繁更新，CPU 占用高，但定位更实时 |
| 适中 (0.1-0.2m) | 平衡计算量和定位精度 |
| 太大 (0.5m) | 更新慢，机器人可能在更新之间"漂移" |

**你会看到的现象**：
- 值太小：CPU 占用高，但机器人位置更新很平滑
- 值太大：机器人在 RViz 中的位置会"跳跃式"更新

### 1.3 里程计误差参数 (odom_alpha1-5)

**生活类比**：里程计就像你数自己走了多少步来估计距离，但每一步的长度不完全一样，会有误差。

```
alpha 参数控制"你有多信任自己数的步数"

alpha 小 (0.1)：                alpha 大 (1.0)：
"我数的步数很准"                "我数的步数不太准"
→ 更信任里程计                  → 更信任激光雷达
→ 定位更平滑                    → 定位可能跳动但更准确
```

**实际效果**：
| 参数 | 含义 | 调大的效果 |
|------|------|-----------|
| alpha1 | 转弯时角度误差 | 转弯后位置更依赖激光修正 |
| alpha2 | 直走时角度误差 | 直走后方向更依赖激光修正 |
| alpha3 | 直走时距离误差 | 直走后距离更依赖激光修正 |
| alpha4 | 转弯时距离误差 | 转弯后距离更依赖激光修正 |

**你会看到的现象**：
- alpha 太小：机器人位置很平滑，但可能慢慢"漂移"偏离真实位置
- alpha 太大：机器人位置会频繁被激光"拉回"，看起来有点跳动

---

## 4. bt_navigator 行为树导航器

**作用**：Nav2 的"总指挥"，使用行为树（Behavior Tree）管理整个导航流程。

**生活类比**：就像一个项目经理，决定"现在该做什么"：
- 收到目标 → 先规划路径
- 路径规划好了 → 开始跟踪
- 跟踪失败了 → 尝试恢复
- 恢复失败了 → 报告失败

```
行为树简化示意：

                    ┌─────────────┐
                    │  导航到目标  │
                    └──────┬──────┘
                           │
              ┌────────────┼────────────┐
              ▼            ▼            ▼
        ┌──────────┐ ┌──────────┐ ┌──────────┐
        │ 规划路径  │ │ 跟踪路径  │ │ 恢复行为  │
        └──────────┘ └──────────┘ └──────────┘
              │            │            │
              ▼            ▼            ▼
        planner_     controller_   behavior_
        server       server        server
```

### 4.1 关键参数

```yaml
bt_navigator:
  ros__parameters:
    global_frame: "map"           # 全局坐标系
    robot_base_frame: "base_link" # 机器人坐标系
    odom_topic: "/odom"           # 里程计话题
    bt_loop_duration: 10          # 行为树循环周期（毫秒）
    default_server_timeout: 20    # 等待其他服务器的超时时间（秒）
    enable_groot_monitoring: True # 是否启用 Groot 可视化调试
```

### 4.2 参数详解

**bt_loop_duration（行为树循环周期）**

```
bt_loop_duration = 10ms

每 10ms 执行一次行为树：
时间 ──→ 0ms   10ms   20ms   30ms   ...
         │     │      │      │
         检查   检查    检查   检查
         状态   状态    状态   状态
```

| 参数值 | 效果 |
|--------|------|
| 太小 (< 5ms) | 响应快，但 CPU 占用高 |
| 适中 (10-20ms) | 平衡响应速度和 CPU |
| 太大 (> 50ms) | 响应慢，可能错过重要事件 |

**default_server_timeout（服务器超时）**

```
default_server_timeout = 20s

bt_navigator 等待 planner_server 响应：
"我要规划路径" ──→ 等待... ──→ 20秒后还没响应 ──→ 超时失败
```

| 参数值 | 效果 |
|--------|------|
| 太小 (< 10s) | 复杂路径规划可能超时失败 |
| 适中 (20-30s) | 大多数情况够用 |
| 太大 (> 60s) | 真正卡住时要等很久才报错 |

**enable_groot_monitoring（Groot 监控）**

Groot 是一个可视化工具，可以实时查看行为树的执行状态。

| 参数值 | 效果 |
|--------|------|
| True | 可以用 Groot 调试，但有网络开销 |
| False | 无法调试，但性能更好 |

### 4.3 plugin_lib_names（行为树插件）

这个列表定义了行为树可以使用的"动作"：

```yaml
plugin_lib_names:
  - nav2_compute_path_to_pose_action_bt_node  # 计算路径
  - nav2_follow_path_action_bt_node           # 跟踪路径
  - nav2_spin_action_bt_node                  # 原地旋转
  - nav2_wait_action_bt_node                  # 等待
  - nav2_back_up_action_bt_node               # 后退
  - nav2_clear_costmap_service_bt_node        # 清除代价地图
  # ... 更多插件
```

**你会看到的现象**：
- 缺少某个插件：行为树执行到该节点时会失败
- 插件列表完整：导航可以执行各种动作（规划、跟踪、旋转、后退等）

---

## 5. controller_server 控制器服务器

控制器的作用是让机器人"怎么走"——走多快、怎么转弯、怎么避障。

**生活类比**：planner_server 是"导航 App 规划路线"，controller_server 是"司机实际开车"。

```
planner_server 规划的路径：        controller_server 实际走的路：
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│  S ─────────────→ G     │      │  S ~~~~~~~~~~~~~~~~~~~→ G│
│  (理想的直线路径)        │      │  (实际会有微调和避障)    │
│                         │      │                         │
└─────────────────────────┘      └─────────────────────────┘
```

### 5.1 基础参数

```yaml
controller_server:
  ros__parameters:
    controller_frequency: 20.0    # 控制频率（Hz）
    min_x_velocity_threshold: 0.001  # 最小速度阈值
    failure_tolerance: 0.3        # 失败容忍度
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"]
    controller_plugins: ["FollowPath"]
```

**controller_frequency（控制频率）**

```
controller_frequency = 20 Hz

每秒计算 20 次速度命令：
时间 ──→ 0ms   50ms   100ms   150ms   ...
         │     │      │       │
         计算   计算    计算    计算
         速度   速度    速度    速度
         ↓     ↓      ↓       ↓
        发布   发布    发布    发布
        cmd_vel
```

| 参数值 | 效果 |
|--------|------|
| 太低 (< 10 Hz) | 控制不平滑，机器人走走停停 |
| 适中 (15-20 Hz) | 控制平滑，CPU 占用合理 |
| 太高 (> 30 Hz) | 控制更精细，但 CPU 占用高 |

**failure_tolerance（失败容忍度）**

```
failure_tolerance = 0.3 (30%)

如果 30% 的控制周期失败，认为控制器失败
```

| 参数值 | 效果 |
|--------|------|
| 太小 (< 0.1) | 偶尔一次失败就放弃，太敏感 |
| 适中 (0.2-0.4) | 容忍偶尔失败，但持续失败会报错 |
| 太大 (> 0.5) | 太宽松，可能掩盖真正的问题 |

### 5.2 progress_checker（进度检查器）

**作用**：检查机器人是否在"前进"，防止卡住。

```yaml
progress_checker:
  plugin: "nav2_controller::SimpleProgressChecker"
  required_movement_radius: 0.1   # 要求移动的最小距离（米）
  movement_time_allowance: 20.0   # 允许的时间（秒）
```

**生活类比**：就像导航 App 说"您似乎没有在移动，是否重新规划路线？"

```
required_movement_radius = 0.1m
movement_time_allowance = 20s

含义：20 秒内必须移动至少 10cm，否则认为"卡住了"

正常情况：                      卡住情况：
┌─────────────────┐            ┌─────────────────┐
│  🚗 ──→ 移动中   │            │  🚗 原地不动     │
│  (20秒内移动>10cm)│            │  (20秒内移动<10cm)│
│  ✓ 继续导航      │            │  ✗ 触发恢复行为  │
└─────────────────┘            └─────────────────┘
```

| 参数 | 调大效果 | 调小效果 |
|------|----------|----------|
| required_movement_radius | 要求移动更多才算"有进展" | 移动一点点就算"有进展" |
| movement_time_allowance | 允许更长时间不动 | 更快判定为"卡住" |

### 5.3 goal_checker（目标检查器）

**作用**：判断是否"到达目标"。

```yaml
general_goal_checker:
  stateful: True
  plugin: "nav2_controller::SimpleGoalChecker"
  xy_goal_tolerance: 0.35    # 位置容差（米）
  yaw_goal_tolerance: 0.35   # 角度容差（弧度）
```

（这部分前面已经详细解释过）

### 5.4 DWB 控制器详解

### 2.1 速度限制 (max_vel_x / max_vel_theta)

**生活类比**：就像汽车的限速。

```
max_vel_x = 0.6 m/s (最快前进速度)
max_vel_theta = 1.0 rad/s (最快转弯速度)

速度太快：                      速度太慢：
┌─────────────────┐            ┌─────────────────┐
│  🚗💨💨💨        │            │  🚗...          │
│  冲过头了！      │            │  慢吞吞...      │
│  撞墙了！        │            │  永远到不了...  │
└─────────────────┘            └─────────────────┘
```

**实际效果**：
| 参数值 | 效果 |
|--------|------|
| max_vel_x 太大 | 机器人冲得太快，来不及避障，可能撞墙 |
| max_vel_x 太小 | 机器人走得太慢，效率低 |
| max_vel_theta 太大 | 转弯太快，可能打滑或不稳定 |
| max_vel_theta 太小 | 转弯太慢，在狭窄空间难以调整方向 |

**你会看到的现象**：
- 速度太快：机器人在转弯处冲出去，或者来不及刹车撞到障碍物
- 速度太慢：机器人像蜗牛一样慢慢移动

### 2.2 加速度限制 (acc_lim_x / acc_lim_theta)

**生活类比**：就像汽车的油门和刹车灵敏度。

```
加速度大 (2.0 m/s²)：           加速度小 (0.5 m/s²)：
速度                            速度
  ↑    /‾‾‾‾‾                    ↑      ___/‾‾‾
  │   /                          │    /
  │  /                           │   /
  │ /                            │  /
  └──────→ 时间                  └──────→ 时间
  快速达到目标速度                慢慢加速，更平稳
```

**实际效果**：
| 参数值 | 效果 |
|--------|------|
| acc_lim_x 太大 | 起步和刹车很猛，可能打滑或不稳定 |
| acc_lim_x 太小 | 起步和刹车很慢，响应迟钝 |
| decel_lim_x 太大 | 急刹车，可能打滑 |
| decel_lim_x 太小 | 刹车距离长，可能撞到障碍物 |

**你会看到的现象**：
- 加速度太大：机器人启动时"窜"出去，停止时"急刹车"
- 加速度太小：机器人启动和停止都很慢，像在水里移动

### 2.3 目标容差 (xy_goal_tolerance / yaw_goal_tolerance)

**生活类比**：就像停车时"差不多到位就行"还是"必须精确停在线内"。

```
xy_goal_tolerance = 0.35m (位置误差 35cm 以内算到达)
yaw_goal_tolerance = 0.35rad (角度误差 20° 以内算到达)

容差大：                        容差小：
┌─────────────────┐            ┌─────────────────┐
│      ⭕         │            │      ⭕         │
│   🚗 ← 到了！   │            │   🚗 ← 还没到！ │
│  (差30cm也算)   │            │  (差5cm才算)    │
└─────────────────┘            └─────────────────┘
```

**实际效果**：
| 参数值 | 效果 |
|--------|------|
| 容差太大 (> 0.5m) | 机器人停得离目标很远就认为"到了" |
| 容差太小 (< 0.1m) | 机器人在目标点附近转圈，无法精确到达 |

**你会看到的现象**：
- 容差太大：机器人停在离目标点很远的地方
- 容差太小：机器人在目标点附近来回晃动，无法停下来

### 2.4 轨迹评估器权重 (Critics)

**生活类比**：机器人在选择怎么走时，会考虑多个因素，每个因素有不同的重要性。

```
评估器就像一群"评委"，给每条可能的路径打分：

PathAlign (24.0)：  "这条路跟规划的路径对齐吗？"
GoalDist (16.0)：   "这条路能让我更接近目标吗？"
BaseObstacle (0.02)："这条路会撞到障碍物吗？"
Oscillation (10.0)： "这条路会让我来回晃动吗？"

最终选择得分最高的路径
```

**实际效果**：
| 评估器 | 权重大的效果 | 权重小的效果 |
|--------|-------------|-------------|
| PathAlign | 严格跟随规划路径，不会抄近路 | 可能偏离路径抄近路 |
| GoalDist | 更积极地朝目标前进 | 可能绕远路 |
| BaseObstacle | 更保守地避开障碍物 | 可能靠近障碍物 |
| Oscillation | 更避免来回晃动 | 可能在狭窄处晃动 |

**你会看到的现象**：
- PathAlign 太大：机器人死板地跟着路径走，即使有更短的路也不走
- GoalDist 太大：机器人急于到达目标，可能忽略障碍物
- Oscillation 太小：机器人在狭窄通道来回晃动

### 2.5 轨迹预测时间 (sim_time)

**生活类比**：就像开车时"看多远"。

```
sim_time = 2.0s (预测未来 2 秒的轨迹)

sim_time 短 (1.0s)：            sim_time 长 (3.0s)：
┌─────────────────┐            ┌─────────────────┐
│  🚗──→          │            │  🚗──────────→  │
│  只看眼前       │            │  看得更远       │
│  可能来不及避障  │            │  提前发现障碍物  │
└─────────────────┘            └─────────────────┘
```

**实际效果**：
| 参数值 | 效果 |
|--------|------|
| sim_time 太短 (< 1.5s) | 机器人"近视"，来不及避开障碍物 |
| sim_time 太长 (> 3.0s) | 计算量大，可能导致控制延迟 |

---

## 6. planner_server 路径规划器

路径规划器的作用是找到从起点到终点的"最佳路线"。

### 6.1 A* vs Dijkstra (use_astar)

**生活类比**：
- **Dijkstra**：像洪水一样向四周扩散，保证找到最短路径
- **A***：像有目标的搜索，更快但可能不是最短

```
Dijkstra (use_astar: false)：   A* (use_astar: true)：
┌─────────────────┐            ┌─────────────────┐
│ ████████████    │            │ ████████████    │
│ S→→→→→→→→→→→G   │            │ S→→→→→→→→→→→G   │
│ ↓↓↓↓↓↓↓↓↓↓↓↓    │            │   ↘↘↘↘↘↘↘↘     │
│ 搜索整个地图     │            │ 只搜索目标方向   │
│ 慢但保证最短     │            │ 快但可能绕路     │
└─────────────────┘            └─────────────────┘
```

**实际效果**：
| 算法 | 效果 |
|------|------|
| Dijkstra | 路径一定是最短的，但规划时间可能较长 |
| A* | 规划更快，但路径可能不是最短的 |

### 6.2 目标容差 (tolerance)

**生活类比**：就像导航说"目的地在道路右侧"，允许一定的误差。

```
tolerance = 0.5m

目标点周围 0.5m 范围内都算"可以到达"
如果目标点正好在障碍物上，规划器会找最近的可到达点
```

**实际效果**：
| 参数值 | 效果 |
|--------|------|
| tolerance 太小 (< 0.2m) | 如果目标点附近有障碍物，可能无法规划路径 |
| tolerance 太大 (> 1.0m) | 路径终点可能离目标很远 |

---

## 7. behavior_server 恢复行为服务器

**作用**：当导航遇到问题时，执行"恢复动作"来解决问题。

**生活类比**：就像开车时遇到死胡同，你会：
1. 先等一等（wait）
2. 倒车（backup）
3. 原地转向（spin）
4. 重新规划路线

```
导航失败时的恢复流程：

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  导航失败 ──→ 尝试恢复行为 ──→ 成功？ ──→ 继续导航          │
│                    │              │                         │
│                    │              └──→ 失败 ──→ 再试一次    │
│                    │                              │         │
│                    ▼                              ▼         │
│              ┌──────────┐                   所有恢复都失败   │
│              │ 1. spin  │ (原地旋转)              │         │
│              │ 2. backup│ (后退)                  ▼         │
│              │ 3. wait  │ (等待)            导航彻底失败     │
│              └──────────┘                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.1 基础参数

```yaml
behavior_server:
  ros__parameters:
    costmap_topic: "local_costmap/costmap_raw"
    footprint_topic: "local_costmap/published_footprint"
    cycle_frequency: 10.0         # 行为执行频率（Hz）
    behavior_plugins: ["spin", "backup", "wait"]
    global_frame: "odom"
    robot_base_frame: "base_link"
    transform_tolerance: 5.0
```

### 7.2 恢复行为详解

**spin（原地旋转）**

```
┌─────────────────┐
│                 │
│    🚗 ↻        │  机器人原地旋转
│                 │  目的：重新扫描周围环境
│                 │        可能发现新的通路
└─────────────────┘
```

**什么时候触发**：
- 路径被障碍物阻挡
- 定位不确定

**backup（后退）**

```
┌─────────────────┐
│                 │
│    ← 🚗        │  机器人向后退
│                 │  目的：离开死角
│                 │        为转向腾出空间
└─────────────────┘
```

**什么时候触发**：
- 前方被堵死
- 无法原地转向

**wait（等待）**

```
┌─────────────────┐
│                 │
│    🚗 ⏳       │  机器人原地等待
│                 │  目的：等待动态障碍物离开
│                 │        （如行人走过）
└─────────────────┘
```

**什么时候触发**：
- 检测到动态障碍物
- 其他恢复行为失败后

### 7.3 参数效果

| 参数 | 效果 |
|------|------|
| cycle_frequency 太低 | 恢复动作执行慢，反应迟钝 |
| cycle_frequency 太高 | CPU 占用高，但恢复更快 |
| behavior_plugins 顺序 | 决定先尝试哪种恢复动作 |

**你会看到的现象**：
- 机器人卡住后原地转圈 → spin 在工作
- 机器人卡住后往后退 → backup 在工作
- 机器人卡住后停着不动 → wait 在工作

---

## 8. local_costmap 局部代价地图

## 8. local_costmap 局部代价地图

**作用**：以机器人为中心的小范围障碍物地图，用于局部避障。

**生活类比**：就像开车时看的"眼前 3 米的路况"。

```
local_costmap 示意：

        机器人视角
           │
           ▼
    ┌─────────────────┐
    │    ░░░░░░░░░    │
    │   ░████████░    │  ← 障碍物（墙）
    │   ░░░░░░░░░░    │
    │                 │
    │       🚗        │  ← 机器人在中心
    │                 │
    │   ░░░░░░░░░░    │
    │   ░████████░    │  ← 障碍物（墙）
    │    ░░░░░░░░░    │
    └─────────────────┘

    地图跟随机器人移动（rolling_window: true）
```

### 8.1 基础参数

```yaml
local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0       # 更新频率（Hz）
      publish_frequency: 2.0      # 发布频率（Hz）
      global_frame: "odom"        # 坐标系（注意：是 odom，不是 map）
      robot_base_frame: "base_link"
      rolling_window: true        # 滚动窗口（跟随机器人）
      width: 3                    # 宽度（米）
      height: 3                   # 高度（米）
      resolution: 0.05            # 分辨率（米/像素）
```

### 8.2 关键参数详解

**rolling_window（滚动窗口）**

```
rolling_window: true              rolling_window: false
(地图跟随机器人移动)              (地图固定不动)

时刻1:                            时刻1:
┌─────┐                          ┌─────────────┐
│ 🚗  │                          │ 🚗          │
└─────┘                          └─────────────┘

时刻2:                            时刻2:
    ┌─────┐                      ┌─────────────┐
    │ 🚗  │                      │     🚗      │
    └─────┘                      └─────────────┘

地图中心始终是机器人              机器人在固定地图中移动
```

**local_costmap 必须用 `rolling_window: true`**，否则机器人走出地图范围就无法避障。

**width / height（地图尺寸）**

```
width = 3m, height = 3m

┌─────────────────┐
│                 │
│    3m × 3m      │
│                 │
│       🚗        │
│                 │
└─────────────────┘

尺寸太小：看不到远处的障碍物
尺寸太大：计算量增加
```

| 参数值 | 效果 |
|--------|------|
| 太小 (< 2m) | 只能看到很近的障碍物，高速时来不及避障 |
| 适中 (3-5m) | 平衡视野和计算量 |
| 太大 (> 8m) | 视野广，但计算量大，更新慢 |

**resolution（分辨率）**

```
resolution = 0.05m (5cm)

每个像素代表 5cm × 5cm 的区域
3m × 3m 的地图 = 60 × 60 = 3600 个像素
```

| 参数值 | 效果 |
|--------|------|
| 太大 (> 0.1m) | 地图粗糙，小障碍物可能被忽略 |
| 适中 (0.05m) | 精度够用，计算量合理 |
| 太小 (< 0.02m) | 地图精细，但计算量大 |

### 8.3 图层（Plugins）

```yaml
plugins: ["voxel_layer", "inflation_layer"]
```

**voxel_layer（体素层）**

```
作用：从传感器数据（激光雷达）检测障碍物

激光雷达 ──→ 检测到障碍物 ──→ 在地图上标记为"障碍物"
         ──→ 没检测到 ──→ 在地图上标记为"可通行"
```

关键参数：
```yaml
voxel_layer:
  enabled: True
  publish_voxel_map: True
  origin_z: 0.0
  z_resolution: 0.05
  z_voxels: 16
  max_obstacle_height: 2.0
  observation_sources: scan

  scan:
    topic: "/scan"
    data_type: "LaserScan"
    marking: True      # 用于标记障碍物
    clearing: True     # 用于清除障碍物
    raytrace_max_range: 3.0
    obstacle_max_range: 2.5
```

| 参数 | 效果 |
|------|------|
| marking: True | 激光打到的地方标记为障碍物 |
| clearing: True | 激光穿过的地方清除障碍物 |
| raytrace_max_range | 清除障碍物的最大距离 |
| obstacle_max_range | 标记障碍物的最大距离 |

**inflation_layer（膨胀层）**

（前面已经详细解释过）

---

## 9. global_costmap 全局代价地图

**作用**：覆盖整个地图的障碍物信息，用于全局路径规划。

**生活类比**：就像导航 App 的"整个城市的交通地图"。

```
global_costmap vs local_costmap：

global_costmap:                   local_costmap:
┌─────────────────────────┐      ┌─────────┐
│                         │      │         │
│  整个地图               │      │  3m×3m  │
│  (可能 50m × 50m)       │      │         │
│                         │      │   🚗    │
│         🚗              │      │         │
│                         │      └─────────┘
│                         │      跟随机器人移动
└─────────────────────────┘      用于局部避障
固定不动
用于全局路径规划
```

### 9.1 基础参数

```yaml
global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0       # 更新频率（Hz）- 比 local 低
      publish_frequency: 1.0      # 发布频率（Hz）
      global_frame: "map"         # 坐标系（注意：是 map，不是 odom）
      robot_base_frame: "base_link"
      resolution: 0.05            # 分辨率（与静态地图一致）
      track_unknown_space: false  # 是否跟踪未知区域
```

### 9.2 与 local_costmap 的区别

| 特性 | global_costmap | local_costmap |
|------|----------------|---------------|
| 坐标系 | map | odom |
| 大小 | 整个地图 | 3-5 米 |
| 滚动窗口 | 否 | 是 |
| 更新频率 | 低 (1 Hz) | 高 (5-10 Hz) |
| 用途 | 全局路径规划 | 局部避障 |

### 9.3 图层（Plugins）

```yaml
plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
```

**static_layer（静态层）**

```
作用：加载静态地图（map_server 提供的地图）

map_server ──→ 静态地图 ──→ static_layer ──→ global_costmap
```

```yaml
static_layer:
  plugin: "nav2_costmap_2d::StaticLayer"
  map_subscribe_transient_local: True  # 确保不丢失地图数据
```

**obstacle_layer（障碍物层）**

```
作用：在静态地图基础上，添加动态检测到的障碍物

静态地图 + 激光雷达检测到的新障碍物 = 最终的 global_costmap
```

**inflation_layer（膨胀层）**

（与 local_costmap 相同）

### 9.4 track_unknown_space（跟踪未知区域）

```yaml
track_unknown_space: false
```

```
track_unknown_space: true         track_unknown_space: false
(未知区域视为可通行)              (未知区域视为障碍物)

┌─────────────────┐              ┌─────────────────┐
│ ████  ░░░░░░░░  │              │ ████  ████████  │
│ ████  ░░░░░░░░  │              │ ████  ████████  │
│       ░░░░░░░░  │              │       ████████  │
│       ░░░░░░░░  │              │       ████████  │
└─────────────────┘              └─────────────────┘
  ░ = 未知区域（灰色）              未知区域被当作障碍物
  可以规划路径穿过                  不能规划路径穿过
```

| 参数值 | 效果 |
|--------|------|
| true | 可以在未知区域规划路径（适合探索） |
| false | 不能在未知区域规划路径（更安全） |

---

## 10. 常见问题与调优

### 问题 1：机器人在目标点附近转圈

**原因**：目标容差太小，机器人无法精确到达

**解决方案**：
```yaml
# 增大目标容差
general_goal_checker:
  xy_goal_tolerance: 0.35  # 从 0.1 增大到 0.35
  yaw_goal_tolerance: 0.35  # 从 0.1 增大到 0.35
```

### 问题 2：机器人撞到障碍物

**原因**：膨胀半径太小，或速度太快

**解决方案**：
```yaml
# 增大膨胀半径
inflation_layer:
  inflation_radius: 0.35  # 从 0.25 增大到 0.35

# 降低速度
FollowPath:
  max_vel_x: 0.4  # 从 0.6 降低到 0.4
```

### 问题 3：机器人无法通过狭窄通道

**原因**：膨胀半径太大，或机器人形状不精确

**解决方案**：
```yaml
# 减小膨胀半径
inflation_layer:
  inflation_radius: 0.20  # 从 0.30 减小到 0.20

# 使用精确的 footprint 而不是 robot_radius
footprint: "[[0.315, 0.20], [0.315, -0.20], [-0.315, -0.20], [-0.315, 0.20]]"
```

### 问题 4：机器人定位不稳定（位置跳动）

**原因**：粒子数太少，或里程计误差参数不合适

**解决方案**：
```yaml
amcl:
  # 增加粒子数
  min_particles: 1000  # 从 500 增加到 1000
  max_particles: 3000  # 从 2000 增加到 3000

  # 调整里程计误差（如果里程计不准）
  odom_alpha3: 0.5  # 增大，更信任激光
```

### 问题 5：机器人走走停停

**原因**：控制器频率太低，或进度检查器太严格

**解决方案**：
```yaml
controller_server:
  controller_frequency: 20.0  # 确保足够高

progress_checker:
  required_movement_radius: 0.05  # 减小要求
  movement_time_allowance: 30.0   # 增加允许时间
```

### 问题 6：路径规划失败

**原因**：目标点在障碍物上，或膨胀区域太大

**解决方案**：
```yaml
GridBased:
  tolerance: 0.8  # 增大容差，允许在目标附近找可达点
  allow_unknown: true  # 允许在未知区域规划
```

---

## 参数调优流程图

```
机器人行为异常
      │
      ▼
┌─────────────────────────────────────────────────────┐
│ 1. 定位问题？                                        │
│    - 位置跳动 → 增加粒子数                           │
│    - 位置漂移 → 调整 odom_alpha                      │
└─────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────────────────┐
│ 2. 路径规划问题？                                    │
│    - 无法规划 → 增大 tolerance，减小 inflation_radius │
│    - 路径绕远 → 尝试 use_astar: true                 │
└─────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────────────────┐
│ 3. 运动控制问题？                                    │
│    - 撞障碍物 → 降低速度，增大 inflation_radius       │
│    - 无法到达 → 增大 goal_tolerance                  │
│    - 来回晃动 → 增大 Oscillation.scale               │
└─────────────────────────────────────────────────────┘
```

---

## 总结：参数与实际效果对照表

| 参数类别 | 参数名 | 调大效果 | 调小效果 |
|----------|--------|----------|----------|
| **定位** | max_particles | 定位更准，CPU 更高 | 定位可能跳动，CPU 更低 |
| **定位** | odom_alpha | 更信任激光，位置可能跳 | 更信任里程计，可能漂移 |
| **速度** | max_vel_x | 走得更快，可能撞墙 | 走得更慢，更安全 |
| **速度** | acc_lim_x | 加速更猛，可能打滑 | 加速更慢，更平稳 |
| **目标** | xy_goal_tolerance | 更容易"到达"，但不精确 | 更精确，但可能到不了 |
| **避障** | inflation_radius | 更保守，可能过不了窄路 | 更激进，可能蹭到障碍物 |
| **规划** | sim_time | 看得更远，计算更慢 | 看得更近，可能来不及避障 |
