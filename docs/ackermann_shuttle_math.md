# 阿克曼底盘 Shuttle 操作数学推导

## 1. 坐标系定义

建立以**后轮轴中心**为原点的坐标系（**俯视图，从上往下看**）：
- **x 轴**：指向车头方向（正前方）
- **y 轴**：指向左侧（垂直于车身）
- **z 轴**：垂直向上（指向读者）

```
  俯视图（从上往下看）
  
              x (前)
              ↑
              |
              ● 前轮 (L, 0)
              |
              | L (轴距)
              |
  y (左) ←----● 后轮 (0, 0)
              
  左转时圆心在左边: O = (0, R)
```

也就是说：
- 后轮在原点 (0, 0)
- 前轮在后轮正前方 (L, 0)
- 左转时，圆心在后轮左边 (0, R)

## 2. 阿克曼转向几何

### 2.1 基本参数

- **L** = 轴距（前轮轴到后轮轴的距离）= 0.40m
- **δ** = 前轮转向角（左转为正）
- **R** = 转弯半径（后轮轴中心到圆心的距离）

### 2.2 推导转弯半径

阿克曼转向的核心约束：**所有轮子都绕同一个圆心旋转**。

后轮没有转向，运动方向沿 x 轴（正前方）。因此：
- 后轮运动方向垂直于"后轮到圆心"的连线
- 圆心必须在后轮的正左方或正右方（y 轴方向）

```
  俯视图（左转，δ > 0）
  
              x (前)
              ↑
              |   ↗ 前轮运动方向（与x轴夹角δ）
              |  /
              | / δ
              ●───── 前轮 (L, 0)
              |
              | L
              |
  ●───────────● 后轮 (0, 0)
  圆心        |
  O(0, R)     ↓ 
              后轮运动方向（沿x轴）
```

设圆心 O 在 (0, R)，即后轮正左方距离 R 处。

前轮在 (L, 0)，转向角为 δ，运动方向为 (cos δ, sin δ)。

**几何约束**：从圆心到前轮的向量，必须垂直于前轮的运动方向。

从圆心 O(0, R) 到前轮 (L, 0) 的向量：
$$\vec{v} = (L - 0, 0 - R) = (L, -R)$$

前轮运动方向：
$$\vec{d} = (\cos\delta, \sin\delta)$$

垂直条件：
$$\vec{v} \cdot \vec{d} = 0$$
$$L \cos\delta + (-R) \sin\delta = 0$$
$$L \cos\delta = R \sin\delta$$

解得：
$$\boxed{R = \frac{L}{\tan\delta}}$$

### 2.3 数值示例

| 参数 | 值 |
|------|-----|
| 轴距 L | 0.40 m |
| 转向角 δ | 26° |
| 转弯半径 R | 0.40 / tan(26°) = 0.40 / 0.488 ≈ **0.82 m** |

## 3. 车辆运动轨迹

### 3.1 前进时的运动

初始状态：
- 后轮轴中心：(0, 0)
- 车头朝向：x 正方向（角度 0）
- 圆心：(0, R)

车辆绕圆心做圆周运动。设行驶弧长为 s，转过角度为 θ。

**弧长与角度关系**：
$$s = R \cdot \theta$$
$$\boxed{\theta = \frac{s}{R} = \frac{s \cdot \tan\delta}{L}}$$

**后轮轴中心位置**：

初始时，后轮相对圆心的角度为 -90°（正下方）。

转过角度 θ 后，相对圆心的角度变为 -90° + θ。

新位置：
$$x = 0 + R \cdot \cos(-90° + \theta) = R \sin\theta$$
$$y = R + R \cdot \sin(-90° + \theta) = R - R \cos\theta = R(1 - \cos\theta)$$

**位移**：
$$\boxed{\Delta x = R \sin\theta}$$
$$\boxed{\Delta y = R(1 - \cos\theta)}$$

**朝向变化**：
$$\boxed{\Delta\psi = \theta = \frac{s}{R}}$$

### 3.2 数值示例（前进 0.3m，转向角 26°）

- R = 0.82 m
- θ = 0.3 / 0.82 = 0.366 rad = **21°**
- Δx = 0.82 × sin(21°) = 0.82 × 0.358 = **0.29 m**
- Δy = 0.82 × (1 - cos(21°)) = 0.82 × 0.066 = **0.054 m**
- 朝向变化 = **21°**（车头向左偏转 21°）

```
  俯视图
  
                x (前)
                ↑
                |  ↗ B点朝向（偏左21°）
                | /
          B ●··/·
           /  θ=21°
    Δy    /   |
  0.054m /    |
        /     |
  ←----●------┴────
  y    A    Δx=0.29m
     (起点)
```

## 4. Shuttle 操作分析

### 4.1 步骤 1：前进 + 左转

```
  俯视图
  
                      x (前)
                      ↑
                      |  ↗ B点朝向（偏左θ）
                      | /
                B ●··/
                 /  θ
    Δy          /   |
               /    |
              /     |
  y ←--------●------┴────
            A    Δx
          (起点)
        
  A: 起点 (0, 0), 朝向 x正方向（0°）
  B: 前进后位置 (R·sinθ, R(1-cosθ)), 朝向 +θ（偏左）
```

### 4.2 步骤 2：后退 + 转向

**关键问题**：后退时应该怎么转向？

在代码中，发布的 cmd_vel 是：
```cpp
publishVelocity(-speed_, angular);  // linear.x < 0, angular.z > 0
```

在 `cmd_vel_to_ackermann.py` 中的转换：
```python
radius = v / omega  # v < 0, omega > 0 → radius < 0
steering = atan(L / radius)  # radius < 0 → steering < 0
```

**结论**：`linear.x < 0` 且 `angular.z > 0` 时，实际转向角为**负值（右转）**！

### 4.3 后退 + 右转的几何分析

后退 + 右转时：
- 转向角 δ' = -δ（负值）
- 圆心在车辆右侧
- 车辆朝向继续向左偏转

```
  俯视图（从 B 点开始后退）
  
              ↗ B点朝向（已偏左θ）
             /
        B ●─/─────────────
           \              
            \  弧长 s     
             \            
              \ θ         
               \          
                ● C (新位置，朝向偏左2θ)
                 \
                  ↘ C点朝向
                  
  注：B在A的左前方，C大致回到A的x位置
```

从 B 点后退，朝向继续向左偏转 θ，到达 C 点。

**C 点相对于 A 的位置**：

这需要坐标变换，比较复杂。但关键结论是：

1. **x 方向**：C 点的 x 坐标接近 A 点（回到原来的 x 位置）
2. **y 方向**：C 点的 y 坐标 > A 点（侧移）
3. **朝向**：C 点朝向 = B 点朝向 + θ = **2θ**

### 4.4 一个完整 Shuttle 周期

| 阶段 | 起点 | 终点 | 朝向变化 |
|------|------|------|----------|
| 前进+左转 | A | B | +θ |
| 后退+右转 | B | C | +θ |
| **总计** | A | C | **+2θ** |

**总角度变化**：
$$\boxed{\Delta\psi_{total} = 2\theta = \frac{2s \cdot \tan\delta}{L}}$$

### 4.5 数值示例

| 参数 | 值 |
|------|-----|
| 轴距 L | 0.40 m |
| 转向角 δ | 26° |
| 前进/后退距离 s | 0.30 m |
| 单次角度变化 θ | 21° |
| **一周期总变化** | **42°** |

## 5. 不同转向角的效果对比

| 转向角 δ | 转弯半径 R | 前进0.3m角度变化 θ | 一周期总变化 2θ |
|----------|-----------|-------------------|----------------|
| 20° | 1.10 m | 15.6° | 31° |
| 26° | 0.82 m | 21.0° | 42° |
| 35° | 0.57 m | 30.1° | 60° |
| 45° | 0.40 m | 43.0° | 86° |
| 50° | 0.34 m | 51.0° | **102°** |

**结论**：使用最大转向角 50°，一个 shuttle 周期可以转约 100°！

## 6. 为什么后退距离 = 前进距离？

**假设**：原来车辆所在的位置是空的（无障碍物）。

如果前进距离 = 后退距离 = s：
- 前进后的 x 位移：Δx₁ = R·sin(θ)
- 后退时，沿着对称的圆弧返回
- 后退后的 x 位移大致抵消（回到原来的 x 位置）

**这确保了**：
1. 车辆不会撞到后方障碍物
2. 车辆保持在大致相同的位置
3. 只有朝向在累积变化

## 7. 代码实现

```cpp
// 转弯半径 R = L / tan(δ)
double computeTurningRadius(double steering_angle_deg) {
    double steering_rad = steering_angle_deg * M_PI / 180.0;
    return wheelbase_ / std::tan(steering_rad);
}

// 行驶距离 s 后转过的角度 θ = s / R
double computeAngleChange(double distance, double steering_angle_deg) {
    double R = computeTurningRadius(steering_angle_deg);
    return distance / R;  // 返回弧度
}

// 一个 shuttle 周期的总角度变化 = 2θ
double angle_per_cycle = 2.0 * computeAngleChange(s, δ);
```

## 8. 总结

阿克曼底盘 Shuttle 操作的核心数学：

1. **转弯半径**：$R = \frac{L}{\tan\delta}$

2. **角度变化**：$\theta = \frac{s}{R} = \frac{s \cdot \tan\delta}{L}$

3. **一周期总变化**：$\Delta\psi = 2\theta = \frac{2s \cdot \tan\delta}{L}$

4. **位移**：
   - $\Delta x \approx 0$（前进和后退抵消）
   - $\Delta y > 0$（侧移累积）
