# ============================================================================
# Nav2 真机环境参数配置文件
# ============================================================================
# 本文件包含 Nav2 导航系统的所有参数配置
# 参数说明：
#   - 每个参数都影响导航系统的特定行为
#   - 修改参数后需要重新编译并重启节点才能生效
#   - 建议先理解参数含义再进行调整
# ============================================================================

# ============================================================================
# map_server: 地图服务器
# ============================================================================
# 功能：加载和发布静态地图（.pgm + .yaml）
# 影响：提供全局地图信息，供路径规划和定位使用
map_server:
  ros__parameters:
    # use_sim_time: 是否使用仿真时间
    # - False: 使用系统真实时间（真机环境）
    # - True: 使用 /clock 话题的仿真时间（Gazebo 等）
    # 影响：时间同步，影响 TF 变换和消息时间戳
    use_sim_time: False

# ============================================================================
# amcl: 自适应蒙特卡洛定位（Adaptive Monte Carlo Localization）
# ============================================================================
# 功能：使用粒子滤波算法确定机器人在地图中的位置
# 影响：定位精度直接影响路径规划和导航准确性
amcl:
  ros__parameters:
    use_sim_time: False  # 是否使用仿真时间（真机环境设为 False）

    # ===== 粒子滤波参数 =====
    # min_particles: 最小粒子数量
    # - 作用：定位失败恢复时的最小粒子数
    # - 影响：值越大，恢复越快但计算量增加
    # - 调优：定位不稳定时可增加到 1000
    min_particles: 500

    # max_particles: 最大粒子数量
    # - 作用：限制粒子数量上限，控制计算量
    # - 影响：值越大定位越精确，但 CPU 占用越高
    # - 调优：大环境（>100m²）建议 2000-5000，小环境 1000-2000
    max_particles: 2000

    # kld_err: KLD 采样误差阈值
    # - 作用：控制自适应粒子数量调整的精度
    # - 影响：值越小粒子数越多，定位越精确但计算量越大
    # - 调优：一般保持 0.01-0.1，定位不稳定时减小
    kld_err: 0.05

    # kld_z: KLD 采样置信度（Z 值）
    # - 作用：统计置信度，影响粒子数量自适应调整
    # - 影响：值越大粒子数越多（99% 置信度对应 0.99）
    # - 调优：一般保持 0.99，不需要修改
    kld_z: 0.99

    # ===== 更新触发条件 =====
    # update_min_d: 最小平移距离阈值（米）
    # - 作用：机器人移动超过此距离才更新定位
    # - 影响：值越大更新频率越低，节省计算但响应变慢
    # - 调优：快速移动机器人可增大到 0.3-0.5，慢速机器人 0.1-0.2
    update_min_d: 0.2

    # update_min_a: 最小旋转角度阈值（弧度）
    # - 作用：机器人旋转超过此角度才更新定位
    # - 影响：值越大更新频率越低
    # - 调优：一般 0.3-0.5 弧度（约 17-29 度），频繁旋转可减小
    update_min_a: 0.5

    # resample_interval: 重采样间隔
    # - 作用：每 N 次更新才进行一次重采样
    # - 影响：值越大重采样越少，计算量小但可能定位退化
    # - 调优：一般保持 1（每次更新都重采样），计算资源紧张时可增大
    resample_interval: 1

    # transform_tolerance: TF 变换容差（秒）
    # - 作用：允许的 TF 变换时间延迟
    # - 影响：值越大对时间同步要求越宽松，但可能使用过时数据
    # - 调优：网络延迟大或 TF 不稳定时可增大到 1.0-2.0
    transform_tolerance: 5.0

    # ===== 恢复行为参数 =====
    # recovery_alpha_slow: 慢速恢复因子
    # - 作用：定位失败时的慢速恢复权重（0=禁用）
    # - 影响：值越大恢复越慢但更稳定
    # - 调优：一般设为 0（禁用），需要时可设为 0.001-0.01
    recovery_alpha_slow: 0.0

    # recovery_alpha_fast: 快速恢复因子
    # - 作用：定位失败时的快速恢复权重（0=禁用）
    # - 影响：值越大恢复越快但可能不稳定
    # - 调优：一般设为 0（禁用），需要时可设为 0.1-0.3
    recovery_alpha_fast: 0.0

    # ===== 初始位姿参数 =====
    # initial_pose.x/y/yaw: 初始位置和朝向
    # - 作用：AMCL 启动时的初始位姿估计
    # - 影响：影响定位收敛速度，不准确会导致定位失败
    # - 调优：应在 RViz2 中使用 "2D Pose Estimate" 设置，这里仅作备用
    initial_pose:
      x: 1.0
      y: 1.7
      yaw: 3.138
      z: 0.0

    # initial_cov_xx/yy/aa: 初始位姿协方差
    # - 作用：初始位姿的不确定性（xx/yy 是位置，aa 是角度）
    # - 影响：值越大初始不确定性越大，粒子分布越广
    # - 调优：初始位置不确定时增大（0.5-1.0），确定时减小（0.1-0.25）
    initial_cov_xx: 0.25  # 位置 X 方向不确定性（米²）
    initial_cov_yy: 0.25  # 位置 Y 方向不确定性（米²）
    initial_cov_aa: 0.07  # 角度不确定性（弧度²），约 ±15 度

    # ===== 激光雷达参数 =====
    # laser_min_range: 最小有效距离（米，-1=使用传感器默认值）
    # - 作用：忽略过近的激光数据（可能是机器人自身反射）
    # - 影响：值越大忽略范围越大，避免误检测但可能丢失近距离障碍物
    # - 调优：机器人半径约 0.2m，建议设为 0.1-0.3
    laser_min_range: -1.0

    # laser_max_range: 最大有效距离（米，-1=使用传感器默认值）
    # - 作用：忽略过远的激光数据（可能不准确）
    # - 影响：值越小计算量越小，但可能丢失远距离信息
    # - 调优：根据激光雷达实际范围设置（如 10-30 米）
    laser_max_range: -1.0

    # laser_max_beams: 使用的最大激光束数量
    # - 作用：限制用于定位的激光数据量
    # - 影响：值越大定位越精确但计算量越大
    # - 调优：高精度激光雷达（如 1080 线）可设为 60-120，低精度 30-60
    laser_max_beams: 60

    # ===== 激光模型参数（likelihood_field 模型）=====
    # laser_model_type: 激光模型类型
    # - "beam": 光束模型（精确但计算量大）
    # - "likelihood_field": 似然场模型（快速且效果好，推荐）
    # - 影响：定位精度和计算性能
    laser_model_type: "likelihood_field"

    # laser_z_hit: 正确测量的权重（概率之和应为 1.0）
    # - 作用：激光数据与地图匹配的权重
    # - 影响：值越大越信任激光数据，定位越精确
    # - 调优：一般 0.9-0.95，激光数据质量好时增大
    laser_z_hit: 0.95

    # laser_z_short: 短距离测量权重（可能是障碍物）
    # - 作用：处理短距离测量的权重
    # - 影响：值越大越信任短距离数据
    # - 调优：一般 0.05-0.1
    laser_z_short: 0.1

    # laser_z_max: 最大距离测量权重（可能是未知区域）
    # - 作用：处理最大距离测量的权重
    # - 影响：值越大越信任最大距离数据
    # - 调优：一般 0.05-0.1
    laser_z_max: 0.05

    # laser_z_rand: 随机测量权重（噪声）
    # - 作用：处理随机噪声的权重
    # - 影响：值越大越容忍噪声，但定位精度下降
    # - 调优：一般 0.05-0.1，噪声大时可增大
    laser_z_rand: 0.05

    # laser_sigma_hit: 激光测量标准差（米）
    # - 作用：激光数据的测量误差模型
    # - 影响：值越大越容忍误差，但定位精度下降
    # - 调优：根据激光雷达精度设置（高精度 0.1-0.2，低精度 0.2-0.3）
    laser_sigma_hit: 0.2

    # laser_lambda_short: 短距离测量衰减系数
    # - 作用：短距离测量的衰减参数
    # - 影响：值越大短距离数据影响越大
    # - 调优：一般保持 0.1，不需要修改
    laser_lambda_short: 0.1

    # laser_likelihood_max_dist: 似然场最大距离（米）
    # - 作用：计算似然场的最大距离范围
    # - 影响：值越大计算量越大，但能处理更远的障碍物
    # - 调优：一般 1.5-2.5 米，大环境可增大
    laser_likelihood_max_dist: 2.0

    # ===== 里程计模型参数 =====
    # odom_model_type: 里程计模型类型
    # - "diff": 差分驱动模型（适用于差速/阿克曼底盘）
    # - "omni": 全向驱动模型（适用于全向轮）
    # - 影响：里程计误差模型，影响定位精度
    odom_model_type: "diff"

    # odom_alpha1-5: 里程计误差参数
    # - alpha1: 旋转对旋转的影响（rad²）
    # - alpha2: 平移对旋转的影响（m²/rad²）
    # - alpha3: 平移对平移的影响（m²）
    # - alpha4: 旋转对平移的影响（m²/rad²）
    # - alpha5: 平移对平移的影响（m²，仅全向模型）
    # - 影响：值越大越不信任里程计，定位更依赖激光
    # - 调优：里程计精度高时减小（0.1-0.2），精度低时增大（0.5-1.0）
    odom_alpha1: 0.2  # 旋转→旋转误差
    odom_alpha2: 0.2  # 平移→旋转误差
    odom_alpha3: 0.8  # 平移→平移误差（最重要）
    odom_alpha4: 0.2  # 旋转→平移误差
    odom_alpha5: 0.1  # 平移→平移误差（全向模型）

    # ===== 坐标系参数 =====
    # odom_frame_id: 里程计坐标系名称
    # - 作用：指定里程计发布的坐标系
    # - 影响：必须与里程计节点发布的 frame_id 一致
    # - 调优：一般保持 "odom"，不要修改
    odom_frame_id: "odom"

    # base_frame_id: 机器人基座坐标系名称
    # - 作用：指定机器人基座坐标系
    # - 影响：必须与 URDF 中的 base_link 一致
    # - 调优：一般保持 "base_link"，不要修改
    base_frame_id: "base_link"

    # global_frame_id: 全局坐标系名称（地图坐标系）
    # - 作用：指定地图坐标系
    # - 影响：必须与 map_server 发布的坐标系一致
    # - 调优：一般保持 "map"，不要修改
    global_frame_id: "map"

    # scan_topic: 激光雷达话题名称
    # - 作用：指定订阅的激光雷达数据话题
    # - 影响：必须与激光雷达节点发布的话题一致
    # - 调优：根据实际激光雷达话题修改（如 "/scan"）
    scan_topic: "/scan"

    # set_initial_pose: 是否设置初始位姿
    # - 作用：启动时是否使用 initial_pose_x/y/a 作为初始位姿
    # - 影响：True 时使用配置的初始位姿，False 时等待手动设置
    # - 调优：真机环境建议 True，但最好在 RViz2 中手动设置
    set_initial_pose: True

# ============================================================================
# bt_navigator: 行为树导航器
# ============================================================================
# 功能：使用行为树（Behavior Tree）管理导航流程和决策逻辑
# 影响：控制导航的整体行为，包括路径规划、跟踪、恢复等
bt_navigator:
  ros__parameters:
    use_sim_time: False  # 是否使用仿真时间

    # global_frame: 全局坐标系名称
    # - 作用：指定全局坐标系（通常是 "map"）
    # - 影响：用于路径规划和目标点转换
    # - 调优：必须与地图坐标系一致，不要修改
    global_frame: "map"

    # robot_base_frame: 机器人基座坐标系
    # - 作用：指定机器人基座坐标系（通常是 "base_link"）
    # - 影响：用于计算机器人位置和姿态
    # - 调优：必须与 URDF 一致，不要修改
    robot_base_frame: "base_link"

    # odom_topic: 里程计话题名称
    # - 作用：订阅里程计数据用于导航
    # - 影响：必须与里程计节点发布的话题一致
    # - 调优：一般保持 "/odom"，不要修改
    odom_topic: "/odom"

    # bt_loop_duration: 行为树循环周期（毫秒）
    # - 作用：行为树执行一次循环的时间间隔
    # - 影响：值越小响应越快但 CPU 占用越高
    # - 调优：一般 10-20ms，性能不足时可增大到 50ms
    bt_loop_duration: 10

    # default_server_timeout: 默认服务器超时时间（秒）
    # - 作用：等待其他服务器（如 planner、controller）响应的超时时间
    # - 影响：值越大越容忍延迟，但响应变慢
    # - 调优：网络延迟大或计算慢时可增大到 30-60 秒
    default_server_timeout: 20

    # enable_groot_monitoring: 是否启用 Groot 监控
    # - 作用：启用 Groot 工具可视化行为树
    # - 影响：True 时可使用 Groot 调试行为树，但增加网络开销
    # - 调优：调试时设为 True，生产环境可设为 False
    enable_groot_monitoring: True

    # groot_zmq_publisher_port: Groot 发布端口
    # - 作用：Groot 工具接收行为树数据的端口
    # - 影响：必须与 Groot 配置一致
    # - 调优：一般保持默认值，不需要修改
    groot_zmq_publisher_port: 1666

    # groot_zmq_server_port: Groot 服务器端口
    # - 作用：Groot 工具连接服务器的端口
    # - 影响：必须与 Groot 配置一致
    # - 调优：一般保持默认值，不需要修改
    groot_zmq_server_port: 1667

    # plugin_lib_names: 行为树插件库名称列表
    # - 作用：注册可用的行为树节点插件
    # - 影响：只有在此列表中的插件才能在行为树中使用
    # - 调优：一般保持默认列表，不需要修改
    # - 注意：这是 Nav2 标准插件列表，包含所有常用的导航行为树节点
    plugin_lib_names:
    - nav2_compute_path_to_pose_action_bt_node
    - nav2_compute_path_through_poses_action_bt_node
    - nav2_smooth_path_action_bt_node
    - nav2_follow_path_action_bt_node
    - nav2_spin_action_bt_node
    - nav2_wait_action_bt_node
    - nav2_assisted_teleop_action_bt_node
    - nav2_back_up_action_bt_node
    - nav2_drive_on_heading_bt_node
    - nav2_clear_costmap_service_bt_node
    - nav2_is_stuck_condition_bt_node
    - nav2_goal_reached_condition_bt_node
    - nav2_goal_updated_condition_bt_node
    - nav2_globally_updated_goal_condition_bt_node
    - nav2_is_path_valid_condition_bt_node
    - nav2_initial_pose_received_condition_bt_node
    - nav2_reinitialize_global_localization_service_bt_node
    - nav2_rate_controller_bt_node
    - nav2_distance_controller_bt_node
    - nav2_speed_controller_bt_node
    - nav2_truncate_path_action_bt_node
    - nav2_goal_updater_node_bt_node
    - nav2_recovery_node_bt_node
    - nav2_pipeline_sequence_bt_node
    - nav2_round_robin_node_bt_node
    - nav2_transform_available_condition_bt_node
    - nav2_time_expired_condition_bt_node
    - nav2_distance_traveled_condition_bt_node
    - nav2_single_trigger_bt_node
    - nav2_is_battery_low_condition_bt_node
    - nav2_navigate_through_poses_action_bt_node
    - nav2_navigate_to_pose_action_bt_node
    - nav2_remove_passed_goals_action_bt_node
    - nav2_planner_selector_bt_node
    - nav2_controller_selector_bt_node
    - nav2_goal_checker_selector_bt_node
    - nav2_controller_cancel_bt_node
    - nav2_path_longer_on_approach_bt_node
    - nav2_wait_cancel_bt_node
    - nav2_spin_cancel_bt_node
    - nav2_back_up_cancel_bt_node
    - nav2_assisted_teleop_cancel_bt_node
    - nav2_drive_on_heading_cancel_bt_node

# ============================================================================
# controller_server: 控制器服务器
# ============================================================================
# 功能：局部路径跟踪控制器，将全局路径转换为速度命令
# 影响：直接影响机器人运动平滑度、避障能力和到达精度
controller_server:
  ros__parameters:
    use_sim_time: False  # 是否使用仿真时间

    # controller_frequency: 控制器运行频率（Hz）
    # - 作用：控制器计算速度命令的频率
    # - 影响：值越大控制越平滑但 CPU 占用越高
    # - 调优：一般 10-20Hz，高速机器人建议 20-30Hz
    # - 修改：从 20.0 降低到 10.0，减轻系统负载，避免消息队列满
    controller_frequency: 10.0

    # min_x/y/theta_velocity_threshold: 最小速度阈值
    # - 作用：低于此速度视为静止
    # - 影响：值越小越敏感，可能产生微小抖动
    # - 调优：一般 0.001-0.01，避免过小导致误判
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.001
    min_theta_velocity_threshold: 0.001

    # failure_tolerance: 失败容忍度（0-1）
    # - 作用：允许的失败率，超过此值认为控制器失败
    # - 影响：值越大越容忍偶尔失败，但可能掩盖问题
    # - 调优：一般 0.2-0.4，环境复杂时可增大
    failure_tolerance: 0.3

    # progress_checker_plugin: 进度检查器插件名称
    # - 作用：检查机器人是否在向目标前进
    # - 影响：防止机器人卡住不动
    # - 调优：一般保持 "progress_checker"，不要修改
    progress_checker_plugin: "progress_checker"

    # goal_checker_plugins: 目标检查器插件列表
    # - 作用：检查是否到达目标点
    # - 影响：决定何时认为导航完成
    # - 调优：可添加多个检查器（如 ["general_goal_checker", "precise_goal_checker"]）
    goal_checker_plugins: ["general_goal_checker"]

    # controller_plugins: 控制器插件列表
    # - 作用：使用的局部路径跟踪控制器
    # - 影响：不同控制器有不同的跟踪策略
    # - 调优：DWB 控制器适合大多数场景，可尝试 "FollowPath" 或 "TEB"
    controller_plugins: ["FollowPath"]

    # ===== 进度检查器配置 =====
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      # required_movement_radius: 要求的最小移动半径（米）
      # - 作用：在指定时间内机器人必须移动超过此距离
      # - 影响：值越小越容易触发失败，值越大越宽松
      # - 修改：设为 0.1，需要有实际移动才算"有进展"
      required_movement_radius: 0.1

      # movement_time_allowance: 移动时间限制（秒）
      # - 作用：在此时长内必须移动 required_movement_radius 距离
      # - 影响：值越大越宽松，允许更长的卡住时间
      # - 修改：设为 15.0 秒，在狭窄空间卡住时更快触发 backup 恢复行为
      movement_time_allowance: 30.0

    # ===== 目标检查器配置 =====
    general_goal_checker:
      # stateful: 是否保持状态
      # - 作用：True 时记住之前的状态，False 时每次重新检查
      # - 影响：True 时更稳定，False 时更灵活
      # - 调优：一般保持 True，不需要修改
      stateful: True

      plugin: "nav2_controller::SimpleGoalChecker"
      # xy_goal_tolerance: 位置容差（米）
      # - 作用：到达目标点时的位置误差容忍范围
      # - 影响：值越大越容易到达，但精度下降；值越小精度高但可能无法到达
      # - 调优：一般 0.2-0.5 米，高精度要求时减小到 0.1-0.2
      # - 注意：过小会导致机器人原地转圈无法到达
      xy_goal_tolerance: 0.35

      # yaw_goal_tolerance: 角度容差（弧度）
      # - 作用：到达目标点时的角度误差容忍范围
      # - 影响：值越大越容易到达，但朝向精度下降
      # - 调优：一般 0.2-0.5 弧度（约 11-29 度），高精度要求时减小
      # - 注意：过小会导致机器人无法对准目标朝向
      yaw_goal_tolerance: 0.35

    # ===== DWB 局部路径跟踪控制器配置 =====
    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      # debug_trajectory_details: 是否输出轨迹调试信息
      # - 作用：在日志中输出详细的轨迹评估信息
      # - 影响：True 时便于调试但日志量大，False 时日志简洁
      # - 调优：调试时设为 True，正常运行时设为 False
      debug_trajectory_details: True

      # ===== 速度限制参数 =====
      # min_vel_x: 最小线速度（m/s，负值表示可倒车）
      # - 作用：允许的最小前进/倒车速度
      # - 影响：负值允许倒车，提高灵活性但可能不安全
      # - 调优：真车环境建议 -0.3 到 0.0，仿真可设为 0.0（禁止倒车）
      min_vel_x: -0.3

      # min_vel_y: 最小横向速度（m/s，全向机器人使用）
      # - 作用：允许的最小横向移动速度
      # - 影响：非全向机器人应设为 0.0
      # - 调优：差速/阿克曼底盘设为 0.0，全向轮可设为负值
      min_vel_y: 0.0

      # max_vel_x: 最大线速度（m/s）
      # - 作用：允许的最大前进速度
      # - 影响：值越大速度越快，但控制难度增加
      # - 调优：降低到 0.4，在狭窄空间更安全
      max_vel_x: 0.4

      # max_vel_y: 最大横向速度（m/s，全向机器人使用）
      # - 作用：允许的最大横向移动速度
      # - 影响：非全向机器人应设为 0.0
      # - 调优：差速/阿克曼底盘设为 0.0
      max_vel_y: 0.0

      # max_vel_theta: 最大角速度（rad/s）
      # - 作用：允许的最大旋转速度
      # - 影响：值越大转向越快，但可能不稳定
      # - 调优：降低到 0.8，在狭窄空间更稳定
      max_vel_theta: 0.8

      # ===== 速度模长限制 =====
      # min_speed_xy: 最小线速度模长（m/s）
      # - 作用：避免选择"几乎静止"的轨迹
      # - 影响：值越大越倾向于运动，但可能无法精确到达
      # - 调优：一般 0.05-0.1，高精度要求时可减小
      min_speed_xy: 0.05

      # max_speed_xy: 最大线速度模长（m/s）
      # - 作用：限制速度上限（通常等于 max_vel_x）
      # - 影响：与 max_vel_x 配合使用
      # - 调优：与 max_vel_x 保持一致
      max_speed_xy: 0.4

      # min_speed_theta: 最小角速度模长（rad/s）
      # - 作用：避免选择"几乎不转"的轨迹
      # - 影响：值越大越倾向于旋转，但可能无法精确对准
      # - 调优：一般 0.0（允许不转），需要时可设为 0.1-0.2
      min_speed_theta: 0.0

      # ===== 加速度限制 =====
      # acc_lim_x: 线加速度限制（m/s²）
      # - 作用：限制线速度变化率
      # - 影响：值越大加速越快，但可能不稳定
      # - 调优：根据机器人物理限制设置（一般 0.5-2.0），真车建议 0.8-1.5
      acc_lim_x: 1.0

      # acc_lim_y: 横向加速度限制（m/s²，全向机器人使用）
      # - 作用：限制横向速度变化率
      # - 影响：非全向机器人应设为 0.0
      # - 调优：差速/阿克曼底盘设为 0.0
      acc_lim_y: 0.0

      # acc_lim_theta: 角加速度限制（rad/s²）
      # - 作用：限制角速度变化率
      # - 影响：值越大转向越快，但可能不稳定
      # - 调优：一般 2.0-5.0，真车建议 2.5-4.0
      acc_lim_theta: 3.0

      # decel_lim_x: 线减速度限制（m/s²，负值）
      # - 作用：限制线速度减小率（制动）
      # - 影响：绝对值越大制动越快，但可能不平稳
      # - 调优：一般 -0.5 到 -2.0，真车建议 -1.0 到 -1.5
      decel_lim_x: -1.0

      # decel_lim_theta: 角减速度限制（rad/s²，负值）
      # - 作用：限制角速度减小率
      # - 影响：绝对值越大停止旋转越快
      # - 调优：一般 -2.0 到 -5.0，真车建议 -2.5 到 -4.0
      decel_lim_theta: -3.0

      # ===== 速度采样参数 =====
      # vx_samples: X 方向速度采样数量
      # - 作用：在 min_vel_x 到 max_vel_x 之间采样多少个速度值
      # - 影响：值越大轨迹选择越多，但计算量越大
      # - 修改：增加到 30，提供更多的倒车速度选择
      vx_samples: 30

      # vy_samples: Y 方向速度采样数量（全向机器人使用）
      # - 作用：横向速度采样数量
      # - 影响：非全向机器人应设为 1 或 5
      # - 调优：差速/阿克曼底盘设为 1-5
      vy_samples: 5

      # vtheta_samples: 角速度采样数量
      # - 作用：在 -max_vel_theta 到 max_vel_theta 之间采样多少个角速度值
      # - 影响：值越大轨迹选择越多，但计算量越大
      # - 修改：增加到 30，提供更多的转向选择
      vtheta_samples: 30

      # ===== 轨迹预测参数 =====
      # sim_time: 轨迹预测时间（秒）
      # - 作用：预测未来多长时间内的轨迹
      # - 影响：值越大预测越远，避障能力越强但计算量越大
      # - 修改：增加到 3.0 秒，让 DWB 预测更长的轨迹，有助于在狭窄空间中找到出路
      sim_time: 3.0

      # linear_granularity: 线性轨迹粒度（米）
      # - 作用：轨迹点之间的最小距离
      # - 影响：值越小轨迹越平滑但计算量越大
      # - 调优：一般 0.02-0.1 米，高精度要求时减小
      linear_granularity: 0.05

      # angular_granularity: 角度轨迹粒度（弧度）
      # - 作用：轨迹点之间的最小角度差
      # - 影响：值越小轨迹越平滑但计算量越大
      # - 调优：一般 0.01-0.05 弧度（约 0.6-3 度）
      angular_granularity: 0.025

      # ===== 其他参数 =====
      # transform_tolerance: TF 变换容差（秒）
      # - 作用：允许的 TF 变换时间延迟
      # - 影响：值越大对时间同步要求越宽松
      # - 调优：一般 0.1-1.0，网络延迟大时可增大
      transform_tolerance: 5.0

      # xy_goal_tolerance: 目标位置容差（米）
      # - 作用：到达目标时的位置误差容忍范围
      # - 影响：与 general_goal_checker 的 xy_goal_tolerance 配合使用
      # - 调优：一般与 goal_checker 保持一致
      xy_goal_tolerance: 0.35

      # trans_stopped_velocity: 静止速度阈值（m/s）
      # - 作用：低于此速度视为静止
      # - 影响：用于判断机器人是否停止
      # - 调优：一般 0.01-0.1，避免过小导致误判
      trans_stopped_velocity: 0.05

      # short_circuit_trajectory_evaluation: 是否短路轨迹评估
      # - 作用：True 时找到第一个有效轨迹就停止搜索
      # - 影响：True 时计算快但可能不是最优轨迹，False 时计算慢但更优
      # - 修改：设为 False，在狭窄空间中需要找到最优轨迹
      short_circuit_trajectory_evaluation: False

      # stateful: 是否保持状态
      # - 作用：True 时记住之前的状态，False 时每次重新计算
      # - 影响：True 时更稳定，False 时更灵活
      # - 调优：一般保持 True，不需要修改
      stateful: True

      # ===== 轨迹评估器（Critics）配置 =====
      # critics: 使用的评估器列表
      # - 作用：评估每个候选轨迹的优劣
      # - 影响：不同评估器关注不同方面（避障、路径对齐、目标距离等）
      # - 调优：可根据需要添加或移除评估器
      # - 注意：移除了 RotateToGoal，因为阿克曼底盘无法原地旋转！
      critics: ["Oscillation", "BaseObstacle", "ObstacleFootprint", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]

      # BaseObstacle.scale: 基础障碍物评估器权重
      # - 作用：评估轨迹是否碰撞障碍物（基于机器人中心点）
      # - 影响：值越大越避免碰撞，但可能过于保守
      # - 调优：增大到 0.05，提高对障碍物的敏感度
      BaseObstacle.scale: 0.05

      # ObstacleFootprint.scale: 机器人轮廓障碍物评估器权重
      # - 作用：评估轨迹是否碰撞障碍物（基于机器人完整轮廓）
      # - 影响：值越大越避免碰撞，比 BaseObstacle 更精确
      # - 调优：增大到 2.0，这是狭窄空间导航的关键参数
      #         确保控制器使用完整足迹进行碰撞检测
      ObstacleFootprint.scale: 2.0

      # PathAlign.scale: 路径对齐评估器权重
      # - 作用：评估轨迹与全局路径的对齐程度
      # - 影响：值越大越倾向于跟随路径，但可能不够灵活
      # - 修改：降低到 12.0，让机器人在狭窄空间中更灵活
      PathAlign.scale: 12.0

      # PathAlign.forward_point_distance: 前向预测距离（米）
      # - 作用：在路径前方多远的位置评估对齐
      # - 影响：值越大考虑越远，但可能不够精确
      # - 调优：一般 0.1-0.3，高速时可增大
      PathAlign.forward_point_distance: 0.1

      # GoalAlign.scale: 目标对齐评估器权重
      # - 作用：评估轨迹朝向目标的程度
      # - 影响：值越大越倾向于朝向目标，但可能不够平滑
      # - 修改：降低到 10.0，允许机器人暂时背对目标（倒车）
      GoalAlign.scale: 10.0

      # GoalAlign.forward_point_distance: 前向预测距离（米）
      # - 作用：在目标前方多远的位置评估对齐
      # - 影响：值越大考虑越远
      # - 调优：一般 0.1-0.3
      GoalAlign.forward_point_distance: 0.1

      # PathDist.scale: 路径距离评估器权重
      # - 作用：评估轨迹与全局路径的距离
      # - 影响：值越大越倾向于靠近路径
      # - 修改：降低到 12.0，让机器人可以暂时偏离路径
      PathDist.scale: 12.0

      # GoalDist.scale: 目标距离评估器权重
      # - 作用：评估轨迹到目标的距离
      # - 影响：值越大越倾向于接近目标
      # - 调优：一般 15-30，接近目标时重要
      GoalDist.scale: 16.0

      # 注意：已移除 RotateToGoal 评估器，因为阿克曼底盘无法原地旋转
      # 如果需要在目标点对准方向，应该通过前进/倒车配合转向来实现

      # Oscillation.scale: 振荡检测评估器权重
      # - 作用：检测和避免机器人来回振荡
      # - 影响：值越大越避免振荡，但可能过于保守
      # - 修改：从 10.0 减到 3.0，允许在狭窄空间中进行小幅调整
      Oscillation.scale: 3.0
      
      # Oscillation 的重置参数
      # - oscillation_reset_dist: 移动多远后重置振荡检测
      # - oscillation_reset_angle: 转多少角度后重置振荡检测
      Oscillation.oscillation_reset_dist: 0.10
      Oscillation.oscillation_reset_angle: 0.20

# ============================================================================
# planner_server: 路径规划器服务器
# ============================================================================
# 功能：全局路径规划，计算从起点到终点的最优路径
# 影响：路径质量直接影响导航效率和成功率
planner_server:
  ros__parameters:
    use_sim_time: False  # 是否使用仿真时间

    # expected_planner_frequency: 期望的规划频率（Hz）
    # - 作用：规划器应该达到的运行频率
    # - 影响：值越大响应越快，但计算压力越大
    # - 调优：一般 10-20Hz，复杂环境可降低到 5-10Hz
    expected_planner_frequency: 20.0

    # planner_plugins: 规划器插件列表
    # - 作用：使用的全局路径规划算法
    # - 影响：不同算法有不同的特点（速度、质量、适用场景）
    # - 调优：可尝试 "GridBased"（快速）、"SmacPlanner"（高质量）、"ThetaStar"（平滑）
    planner_plugins: ["GridBased"]

    # ===== Smac Hybrid-A* 规划器配置 =====
    # 说明：SmacPlannerHybrid 支持 SE2 足迹碰撞检测，能精确判断非圆形机器人能否通过狭窄空间
    GridBased:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      
      # tolerance: 目标容差（米）
      # - 作用：允许的路径终点与目标点的距离误差
      # - 调优：一般 0.25-0.5 米
      tolerance: 0.5
      
      # downsample_costmap: 是否下采样代价地图
      # - 作用：降低计算复杂度
      # - 影响：True 时更快但精度降低
      downsample_costmap: false
      downsampling_factor: 1
      
      # allow_unknown: 是否允许在未知区域规划
      allow_unknown: true
      
      # max_iterations: 最大规划迭代次数
      max_iterations: 1000000
      
      # max_planning_time: 最大规划时间（秒）
      max_planning_time: 5.0
      
      # motion_model: 运动模型
      # - "REEDS_SHEPP": 可前进后退（适合差速/阿克曼底盘）
      # - "DUBIN": 只能前进（适合只能前进的底盘）
      motion_model: "REEDS_SHEPP"
      
      # angle_quantization_bins: 角度量化数（角度分辨率 = 360/bins）
      # - 作用：控制路径的角度精度
      # - 影响：值越大角度越精确但计算量越大
      angle_quantization_bins: 72
      
      # minimum_turning_radius: 最小转弯半径（米）
      # - 作用：机器人的物理转弯限制
      # - 调优：根据阿克曼底盘的实际转弯半径设置
      minimum_turning_radius: 0.4
      
      # analytic_expansion: 分析扩展参数
      analytic_expansion_ratio: 3.5
      analytic_expansion_max_length: 3.0
      
      # smooth_path: 是否平滑路径
      smooth_path: true
      
      # 惩罚系数
      cost_penalty: 2.0           # 代价惩罚
      change_penalty: 0.0         # 方向改变惩罚
      non_straight_penalty: 1.2   # 非直线惩罚
      reverse_penalty: 2.0        # 倒车惩罚
      
      # lookup_table_size: 启发式查找表大小
      lookup_table_size: 20.0
      cache_obstacle_heuristic: false

# ============================================================================
# behavior_server: 恢复行为服务器
# ============================================================================
# 功能：当导航失败时执行恢复行为（旋转、后退、等待等）
# 影响：恢复行为帮助机器人摆脱卡住或失败的状态
behavior_server:
  ros__parameters:
    use_sim_time: False  # 是否使用仿真时间

    # costmap_topic: 代价地图话题名称
    # - 作用：订阅局部代价地图用于恢复行为
    # - 影响：必须与 local_costmap 发布的话题一致
    # - 调优：一般保持默认值，不要修改
    costmap_topic: "local_costmap/costmap_raw"

    # footprint_topic: 机器人轮廓话题名称
    # - 作用：订阅机器人轮廓信息
    # - 影响：用于碰撞检测
    # - 调优：一般保持默认值，不要修改
    footprint_topic: "local_costmap/published_footprint"

    # cycle_frequency: 行为循环频率（Hz）
    # - 作用：恢复行为执行的频率
    # - 影响：值越大响应越快但 CPU 占用越高
    # - 调优：一般 5-10Hz，不需要太高
    cycle_frequency: 10.0

    # behavior_plugins: 恢复行为插件列表
    # - 作用：可用的恢复行为（按顺序执行）
    # - 影响：不同行为有不同的恢复策略
    # - 注意：必须保留 spin，因为默认行为树需要它
    #         调整顺序：先 backup，再 spin（会快速失败），最后 wait
    behavior_plugins: ["backup", "spin", "wait"]

    # ===== 旋转行为配置 =====
    # 注意：阿克曼底盘不能原地旋转，此行为会快速失败
    # 但必须保留，因为默认行为树需要这个 action server
    spin:
      plugin: "nav2_behaviors/Spin"
      # simulate_ahead_time: 模拟时间（秒）
      simulate_ahead_time: 1.0
      # max_rotational_vel: 最大旋转速度（rad/s）
      max_rotational_vel: 0.5
      # min_rotational_vel: 最小旋转速度（rad/s）
      min_rotational_vel: 0.2
      # time_allowance: 超时时间（秒）- 设为 2 秒快速失败
      time_allowance: 2.0

    # ===== 后退行为配置 =====
    backup:
      plugin: "nav2_behaviors/BackUp"
      # 调整倒车参数，让机器人在狭窄空间能够更好地脱困
      speed_xy: 0.1           # 倒车速度（m/s），低速安全
      speed_theta: 0.0        # 阿克曼底盘不能原地转向
      time_allowance: 10.0    # 倒车最大时间（秒）

    # ===== 等待行为配置 =====
    wait:
      plugin: "nav2_behaviors/Wait"
      # 注意：具体参数在 behavior_server 的配置中设置
      # 如需调整，可添加以下参数：
      # - wait_duration: 等待时间（秒）

    # global_frame: 全局坐标系名称
    # - 作用：恢复行为使用的坐标系
    # - 影响：必须与 local_costmap 的 global_frame 一致
    # - 调优：一般保持 "odom"，不要修改
    global_frame: "odom"

    # robot_base_frame: 机器人基座坐标系
    # - 作用：指定机器人基座坐标系
    # - 影响：必须与 URDF 一致
    # - 调优：一般保持 "base_link"，不要修改
    robot_base_frame: "base_link"

    # transform_tolerance: TF 变换容差（秒）
    # - 作用：允许的 TF 变换时间延迟
    # - 影响：值越大对时间同步要求越宽松
    # - 调优：一般 0.1-1.0，网络延迟大时可增大
    transform_tolerance: 5.0

# ============================================================================
# local_costmap: 局部代价地图
# ============================================================================
# 功能：以机器人为中心的局部障碍物地图，用于局部路径规划和避障
# 影响：直接影响局部路径跟踪和避障能力
local_costmap:
  local_costmap:
    ros__parameters:
      use_sim_time: False  # 是否使用仿真时间

      # update_frequency: 更新频率（Hz）
      # - 作用：代价地图更新的频率
      # - 影响：值越大更新越快但计算量越大
      # - 调优：一般 5-10Hz，高速机器人建议 10-20Hz
      update_frequency: 5.0

      # publish_frequency: 发布频率（Hz）
      # - 作用：发布代价地图的频率
      # - 影响：值越大可视化更新越快但带宽占用越大
      # - 调优：一般 1-5Hz，调试时可增大
      publish_frequency: 2.0

      # global_frame: 全局坐标系名称
      # - 作用：局部代价地图使用的全局坐标系
      # - 影响：必须与里程计坐标系一致（通常是 "odom"）
      # - 调优：一般保持 "odom"，不要修改
      global_frame: "odom"

      # robot_base_frame: 机器人基座坐标系
      # - 作用：指定机器人基座坐标系
      # - 影响：必须与 URDF 一致
      # - 调优：一般保持 "base_link"，不要修改
      robot_base_frame: "base_link"

      # transform_tolerance: TF 变换容差（秒）
      # - 作用：允许的 TF 变换时间延迟
      # - 影响：值越大对时间同步要求越宽松
      # - 调优：一般 0.1-1.0，网络延迟大时可增大
      transform_tolerance: 5.0

      # rolling_window: 是否使用滚动窗口
      # - 作用：True 时代价地图跟随机器人移动（滚动窗口）
      # - 影响：True 时节省内存，False 时固定在地图坐标系
      # - 调优：局部代价地图必须设为 True，不要修改
      rolling_window: true

      # width/height: 代价地图尺寸（米）
      # - 作用：局部代价地图的宽度和高度
      # - 影响：值越大覆盖范围越大但计算量越大
      # - 调优：一般 3-10 米，高速机器人建议 5-10 米
      width: 5
      height: 5

      # resolution: 分辨率（米/像素）
      # - 作用：每个像素代表的实际距离
      # - 影响：值越小精度越高但计算量越大
      # - 调优：一般 0.05-0.1 米，高精度要求时减小到 0.02-0.05
      resolution: 0.05

      # ===== 机器人形状配置 =====
      # 使用 footprint（多边形足迹）替代 robot_radius，更精确地表示长方形机器人
      # robot_radius: 机器人半径（米）- 已废弃，改用 footprint
      # - 作用：用于计算机器人内切半径和碰撞检测（圆形近似）
      # - 影响：值越大安全距离越大，但可能无法通过狭窄通道
      # - 调优：根据机器人实际尺寸设置（一般 0.15-0.25 米）
      # - 注意：必须小于 inflation_radius
      # robot_radius: 0.18

      # footprint: 机器人多边形足迹（相对于 base_link，单位：米）
      # - 作用：精确定义机器人的形状，用于碰撞检测
      # - 影响：比 robot_radius 更准确，特别是对于长方形机器人
      # - 格式：[[x1,y1], [x2,y2], [x3,y3], [x4,y4]]，按逆时针顺序
      # - 计算：机器人长 0.63m，宽 0.40m，base_link 为中心
      #   - 前右：[0.315, 0.20]  (长度一半=0.315, 宽度一半=0.20)
      #   - 前左：[0.315, -0.20]
      #   - 后左：[-0.315, -0.20]
      #   - 后右：[-0.315, 0.20]
      # - 调优：根据 URDF 中的实际尺寸调整
      # - 注意：如果设置了 footprint，robot_radius 将被忽略
      footprint: "[[0.315, 0.20], [0.315, -0.20], [-0.315, -0.20], [-0.315, 0.20]]"

      # plugins: 代价地图图层插件列表（按顺序执行）
      # - 作用：不同图层提供不同的障碍物信息
      # - 影响：图层顺序影响最终代价计算
      # - 调优：一般 ["voxel_layer", "inflation_layer"]，可根据需要添加其他图层
      plugins: ["voxel_layer", "inflation_layer"]

      # ===== 膨胀图层配置 =====
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        # cost_scaling_factor: 代价缩放因子
        # - 作用：控制障碍物周围代价的衰减速度
        # - 影响：值越大衰减越快，成本梯度越陡峭
        # - 调优：设为10.0，快速衰减，这样膨胀区域有成本但不会堵死通道
        cost_scaling_factor: 40.0

        # inflation_radius: 膨胀半径（米）
        # - 作用：障碍物周围产生代价的区域半径
        # - 修改：进一步减小到 0.05m
        #         在 0.6m 通道中：0.6m - 2*0.05m = 0.50m 可用空间
        #         机器人宽度 0.4m 有足够余量
        # - 注意：真正的碰撞检测由控制器的 ObstacleFootprint critic 完成
        inflation_radius: 0.05

      # ===== 体素图层配置 =====
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        # enabled: 是否启用图层
        # - 作用：True 时图层生效，False 时忽略
        # - 影响：False 时无法检测障碍物
        # - 调优：必须设为 True，不要修改
        enabled: True

        # publish_voxel_map: 是否发布体素地图
        # - 作用：True 时发布 3D 体素地图用于可视化
        # - 影响：True 时便于调试但增加计算和带宽
        # - 调优：调试时设为 True，正常运行时可设为 False
        publish_voxel_map: True
        
        # inf_is_valid: 是否将激光返回 inf（无穷远）视为有效
        # - 作用：True 时，inf 数据用于清除障碍物
        # - 影响：False 时，inf 数据被忽略，不会误清除真实障碍物
        # - 修改：设为 False，防止清空 costmap 后立即认为前方无障碍
        inf_is_valid: False

        # origin_z: Z 轴原点（米）
        # - 作用：体素地图的 Z 轴起始位置
        # - 影响：通常设为 0.0（地面）
        # - 调优：一般保持 0.0，不需要修改
        origin_z: 0.0

        # z_resolution: Z 轴分辨率（米）
        # - 作用：体素在 Z 方向的高度
        # - 影响：值越小精度越高但计算量越大
        # - 调优：一般 0.05-0.1 米
        z_resolution: 0.05

        # z_voxels: Z 轴体素数量
        # - 作用：体素地图在 Z 方向的高度（体素数）
        # - 影响：值越大检测高度越大但计算量越大
        # - 调优：一般 10-20，检测高度 = z_resolution × z_voxels
        z_voxels: 16

        # min_obstacle_height: 最小障碍物高度（米）
        # - 作用：低于此高度的障碍物被忽略（过滤地面反射和低矮噪声）
        # - 影响：2D激光雷达必须设为0，否则无法检测障碍物
        # - 调优：2D激光雷达设为0.0，3D点云可设为0.1-0.2
        min_obstacle_height: 0.0

        # max_obstacle_height: 最大障碍物高度（米）
        # - 作用：超过此高度的障碍物被忽略
        # - 影响：值越大检测范围越大但可能误检测
        # - 调优：根据机器人高度设置（一般 1.5-3.0 米）
        max_obstacle_height: 1.5

        # mark_threshold: 标记阈值
        # - 作用：体素被标记为障碍物所需的最小占用数
        # - 影响：值越大越不容易标记障碍物，但更稳定
        # - 调优：设为0让任何检测都标记为障碍物
        mark_threshold: 0

        # observation_sources: 观测源列表
        # - 作用：指定使用的传感器数据源
        # - 影响：可添加多个传感器（如 scan, pointcloud）
        # - 调优：根据实际传感器配置，一般 ["scan"]
        observation_sources: scan

        # ===== 激光雷达观测源配置 =====
        scan:
          # topic: 激光雷达话题名称
          # - 作用：订阅的激光雷达数据话题
          # - 影响：必须与激光雷达节点发布的话题一致
          # - 修改：改用 /scan（原始数据），避免 scan_filter 增加延迟
          #         这样清空 costmap 后能立即检测到障碍物
          topic: "/scan"

          # max_obstacle_height: 最大障碍物高度（米）
          # - 作用：激光数据中超过此高度的点被忽略
          # - 影响：与图层级别的 max_obstacle_height 配合使用
          # - 调优：一般与图层级别保持一致
          max_obstacle_height: 2.0

          # clearing: 是否用于清除障碍物
          # - 作用：True 时激光数据可用于清除已标记的障碍物
          # - 影响：True 时地图更准确，False 时障碍物不会消失
          # - 调优：必须设为 True，不要修改
          clearing: True

          # marking: 是否用于标记障碍物
          # - 作用：True 时激光数据可用于标记障碍物
          # - 影响：True 时能检测障碍物，False 时无法检测
          # - 调优：必须设为 True，不要修改
          marking: True

          # data_type: 数据类型
          # - 作用：指定传感器数据类型
          # - 影响：必须与传感器实际类型一致
          # - 调优：激光雷达为 "LaserScan"，点云为 "PointCloud2"
          data_type: "LaserScan"

          # raytrace_max_range: 光线追踪最大距离（米）
          # - 作用：清除障碍物时的最大光线追踪距离
          # - 影响：值越大清除范围越大但计算量越大
          # - 调优：一般 2.0-5.0 米，根据激光雷达范围设置
          raytrace_max_range: 3.0

          # raytrace_min_range: 光线追踪最小距离（米）
          # - 作用：清除障碍物时的最小光线追踪距离
          # - 影响：通常设为 0.0
          # - 调优：一般保持 0.0，不需要修改
          raytrace_min_range: 0.0

          # obstacle_max_range: 障碍物检测最大距离（米）
          # - 作用：标记障碍物时的最大检测距离
          # - 影响：值越大检测范围越大但可能不准确
          # - 调优：一般 2.0-5.0 米，根据激光雷达精度设置
          obstacle_max_range: 2.5

          # obstacle_min_range: 障碍物检测最小距离（米）
          # - 作用：标记障碍物时的最小检测距离
          # - 影响：过滤掉太近的噪声（如机器人自身反射）
          # - 调优：设为0.1允许检测近距离障碍物
          obstacle_min_range: 0.1
          
          # sensor_frame: 传感器坐标系
          # - 作用：指定激光雷达的 TF 坐标系名称
          # - 修改：明确指定为 "lidar"，与 TF 一致
          sensor_frame: "lidar"

      # always_send_full_costmap: 是否总是发送完整代价地图
      # - 作用：True 时每次更新都发送完整地图，False 时只发送变化部分
      # - 影响：True 时带宽占用大但更可靠，False 时带宽小但可能丢失数据
      # - 调优：一般保持 True，网络带宽充足时不需要修改
      always_send_full_costmap: True

# ============================================================================
# global_costmap: 全局代价地图
# ============================================================================
# 功能：覆盖整个地图的全局障碍物地图，用于全局路径规划
# 影响：直接影响全局路径规划的质量和成功率
global_costmap:
  global_costmap:
    ros__parameters:
      use_sim_time: False  # 是否使用仿真时间

      # update_frequency: 更新频率（Hz）
      # - 作用：代价地图更新的频率
      # - 影响：值越大更新越快但计算量越大
      # - 调优：全局地图更新不需要太频繁，一般 0.5-2.0Hz
      update_frequency: 1.0

      # publish_frequency: 发布频率（Hz）
      # - 作用：发布代价地图的频率
      # - 影响：值越大可视化更新越快但带宽占用越大
      # - 调优：一般 0.5-2.0Hz，调试时可增大
      publish_frequency: 1.0

      # global_frame: 全局坐标系名称
      # - 作用：全局代价地图使用的坐标系（必须是 "map"）
      # - 影响：必须与地图坐标系一致
      # - 调优：必须保持 "map"，不要修改
      global_frame: "map"

      # robot_base_frame: 机器人基座坐标系
      # - 作用：指定机器人基座坐标系
      # - 影响：必须与 URDF 一致
      # - 调优：一般保持 "base_link"，不要修改
      robot_base_frame: "base_link"

      # transform_tolerance: TF 变换容差（秒）
      # - 作用：允许的 TF 变换时间延迟
      # - 影响：值越大对时间同步要求越宽松
      # - 调优：一般 0.1-1.0，网络延迟大时可增大
      transform_tolerance: 5.0

      # ===== 机器人形状配置 =====
      # 使用 footprint（多边形足迹）替代 robot_radius，更精确地表示长方形机器人
      # robot_radius: 机器人半径（米）- 已废弃，改用 footprint
      # - 作用：用于计算机器人内切半径和碰撞检测（圆形近似）
      # - 影响：值越大安全距离越大，但可能无法通过狭窄通道
      # - 调优：根据机器人实际尺寸设置（一般 0.2-0.3 米）
      # - 注意：全局地图的 robot_radius 可能略大于局部地图（考虑安全余量）
      # robot_radius: 0.22

      # footprint: 机器人多边形足迹（相对于 base_link，单位：米）
      # - 作用：精确定义机器人的形状，用于碰撞检测
      # - 影响：比 robot_radius 更准确，特别是对于长方形机器人
      # - 格式：[[x1,y1], [x2,y2], [x3,y3], [x4,y4]]，按逆时针顺序
      # - 计算：机器人长 0.63m，宽 0.40m，base_link 为中心
      #   - 前右：[0.315, 0.20]  (长度一半=0.315, 宽度一半=0.20)
      #   - 前左：[0.315, -0.20]
      #   - 后左：[-0.315, -0.20]
      #   - 后右：[-0.315, 0.20]
      # - 调优：根据 URDF 中的实际尺寸调整
      # - 注意：如果设置了 footprint，robot_radius 将被忽略
      footprint: "[[0.315, 0.20], [0.315, -0.20], [-0.315, -0.20], [-0.315, 0.20]]"

      # resolution: 分辨率（米/像素）
      # - 作用：每个像素代表的实际距离
      # - 影响：值越小精度越高但计算量和内存占用越大
      # - 调优：必须与地图分辨率一致（一般 0.05 米），不要修改
      resolution: 0.05

      # track_unknown_space: 是否跟踪未知区域
      # - 作用：True 时将未知区域（灰色）视为可通行，False 时视为障碍物
      # - 影响：True 时更灵活但可能不安全，False 时更安全但可能无法规划
      # - 调优：地图完整时设为 False，地图不完整时设为 True
      track_unknown_space: false

      # plugins: 代价地图图层插件列表（按顺序执行）
      # - 作用：不同图层提供不同的障碍物信息
      # - 影响：图层顺序影响最终代价计算（通常 static_layer 在最底层）
      # - 调优：一般 ["static_layer", "obstacle_layer", "inflation_layer"]
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

      # ===== 障碍物图层配置 =====
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        # enabled: 是否启用图层
        # - 作用：True 时图层生效，False 时忽略
        # - 影响：False 时无法检测动态障碍物
        # - 调优：必须设为 True，不要修改
        enabled: True

        # min_obstacle_height: 最小障碍物高度（米）
        # - 作用：低于此高度的障碍物被忽略（过滤地面反射）
        # - 影响：值越大过滤越多，但可能漏检低矮障碍物
        # - 调优：设为 0.1-0.2 米可过滤大部分地面噪声
        min_obstacle_height: 0.25

        # max_obstacle_height: 最大障碍物高度（米）
        # - 作用：超过此高度的障碍物被忽略
        # - 影响：值越大检测范围越大但可能误检测高处反射
        max_obstacle_height: 2.0

        # observation_sources: 观测源列表
        # - 作用：指定使用的传感器数据源
        # - 影响：可添加多个传感器（如 scan, pointcloud）
        # - 调优：根据实际传感器配置，一般 ["scan"]
        observation_sources: scan

        # ===== 激光雷达观测源配置 =====
        scan:
          # topic: 激光雷达话题名称
          # - 作用：订阅的激光雷达数据话题
          # - 影响：必须与激光雷达节点发布的话题一致
          # - 调优：根据实际激光雷达话题修改（如 "/scan"）
          topic: "/scan"

          # min_obstacle_height: 最小障碍物高度（米）
          # - 作用：低于此高度的激光点被忽略
          min_obstacle_height: 0.15

          # max_obstacle_height: 最大障碍物高度（米）
          # - 作用：激光数据中超过此高度的点被忽略
          # - 影响：值越大检测范围越大但可能误检测
          # - 调优：根据机器人高度设置（一般 1.5-3.0 米）
          max_obstacle_height: 1.5

          # clearing: 是否用于清除障碍物
          # - 作用：True 时激光数据可用于清除已标记的障碍物
          # - 影响：True 时地图更准确，False 时障碍物不会消失
          # - 调优：必须设为 True，不要修改
          clearing: True

          # marking: 是否用于标记障碍物
          # - 作用：True 时激光数据可用于标记障碍物
          # - 影响：True 时能检测障碍物，False 时无法检测
          # - 调优：必须设为 True，不要修改
          marking: True

          # data_type: 数据类型
          # - 作用：指定传感器数据类型
          # - 影响：必须与传感器实际类型一致
          # - 调优：激光雷达为 "LaserScan"，点云为 "PointCloud2"
          data_type: "LaserScan"

          # raytrace_max_range: 光线追踪最大距离（米）
          # - 作用：清除障碍物时的最大光线追踪距离
          # - 影响：值越大清除范围越大但计算量越大
          # - 调优：一般 2.0-5.0 米，根据激光雷达范围设置
          raytrace_max_range: 3.0

          # raytrace_min_range: 光线追踪最小距离（米）
          # - 作用：清除障碍物时的最小光线追踪距离
          # - 影响：通常设为 0.0
          # - 调优：一般保持 0.0，不需要修改
          raytrace_min_range: 0.0

          # obstacle_max_range: 障碍物检测最大距离（米）
          # - 作用：标记障碍物时的最大检测距离
          # - 影响：值越大检测范围越大但可能不准确
          # - 调优：一般 2.0-5.0 米，根据激光雷达精度设置
          obstacle_max_range: 2.5

          # obstacle_min_range: 障碍物检测最小距离（米）
          # - 作用：标记障碍物时的最小检测距离
          # - 影响：过滤掉太近的噪声（如机器人自身、地面反射）
          # - 调优：设为机器人半径左右，过滤近距离噪声
          obstacle_min_range: 0.35

      # ===== 静态图层配置 =====
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        # map_subscribe_transient_local: 是否使用瞬态本地订阅
        # - 作用：True 时使用瞬态本地 QoS，确保不丢失地图数据
        # - 影响：True 时更可靠，False 时可能丢失地图更新
        # - 调优：必须设为 True，不要修改
        map_subscribe_transient_local: True

      # ===== 膨胀图层配置 =====
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        # cost_scaling_factor: 代价缩放因子
        # - 作用：控制障碍物周围代价的衰减速度
        # - 影响：值越大衰减越快
        # - 调优：设为5.0，适度衰减创建平滑势能场
        cost_scaling_factor: 5.0

        # inflation_radius: 膨胀半径（米）
        # - 作用：障碍物周围产生代价的区域半径
        # - 影响：设为0.05m，配合Smac的SE2足迹碰撞检测
        #         允许规划器规划进入0.6m的狭窄通道
        # - 注意：真正的碰撞检测由Smac的footprint完成，这里只做轻微膨胀
        inflation_radius: 0.05

      # always_send_full_costmap: 是否总是发送完整代价地图
      # - 作用：True 时每次更新都发送完整地图，False 时只发送变化部分
      # - 影响：True 时带宽占用大但更可靠，False 时带宽小但可能丢失数据
      # - 调优：一般保持 True，网络带宽充足时不需要修改
      always_send_full_costmap: True
